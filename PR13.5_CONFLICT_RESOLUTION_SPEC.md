# PR #13.5 - Conflict Resolution & Simultaneous Edit Handling

**Branch:** `feature/conflict-resolution`  
**Status:** ðŸ“‹ Specification Complete  
**Priority:** High (Critical Infrastructure)  
**Rubric Section:** 1 (Collaborative Infrastructure)

---

## Executive Summary

This PR implements robust conflict resolution for simultaneous edits in the collaborative canvas. While the current system uses server-authoritative updates with Firestore, it lacks explicit conflict detection, visual feedback, and handling for edge cases like delete-while-editing or rapid edit storms.

**Goal:** Ensure that when multiple users edit the same object simultaneously, all users converge to a consistent final state with clear visual feedback about conflicts.

---

## Problem Statement

### Current State
- Basic Firestore real-time sync with implicit last-write-wins
- No visual feedback when user's edit is overwritten
- No detection of conflicting operations
- No handling for edge cases (delete vs edit, rapid storms)
- Users confused when their changes "disappear"

### Target State
- **Explicit conflict detection** with type categorization
- **Visual feedback** (flash + toast) when conflicts occur
- **Optimistic updates** for instant UI response
- **Documented strategy** (Last-Write-Wins with timestamps)
- **Edge case handling** (delete vs edit, rapid edits, etc.)
- **Rate limiting** to prevent quota exhaustion
- **Comprehensive testing** of all conflict scenarios

---

## Conflict Resolution Strategy

### Approach: Last-Write-Wins (LWW) with Firestore Server Timestamps

**Why LWW?**
1. **Simple & Predictable:** Easy for users to understand
2. **Firestore Native:** Works naturally with Firestore's real-time sync
3. **No Complex Algorithms:** No need for OT (Operational Transform) or CRDT
4. **Proven at Scale:** Used by Google Docs, Figma, Miro, etc.

**How It Works:**
```typescript
// Every shape update includes server timestamp
updateShape(id, {
  x: 100,
  y: 200,
  lastModifiedTimestamp: serverTimestamp(), // Firestore server time
  lastModifiedBy: currentUser.uid,
  version: shape.version + 1 // Increment version
});

// On receiving remote update
if (remoteUpdate.lastModifiedTimestamp > localUpdate.lastModifiedTimestamp) {
  // Remote wins, apply it
  applyRemoteUpdate(remoteUpdate);
  showConflictIndicator("Your change was overwritten by " + remoteUpdate.lastModifiedBy);
} else {
  // Local wins, ignore remote
  // (Remote user will see the conflict)
}
```

---

## Technical Architecture

### 1. Conflict Detection System

**File:** `src/utils/conflictDetection.ts`

```typescript
enum ConflictType {
  SIMULTANEOUS_MOVE = 'simultaneous_move',
  RAPID_EDIT_STORM = 'rapid_edit_storm',
  DELETE_WHILE_EDITING = 'delete_while_editing',
  CREATE_COLLISION = 'create_collision',
  NONE = 'none'
}

interface ConflictResult {
  hasConflict: boolean;
  type: ConflictType;
  winner: Operation;
  loser: Operation;
  resolution: string;
}

function detectConflict(localOp: Operation, remoteOp: Operation): ConflictResult {
  // Compare timestamps
  if (remoteOp.timestamp > localOp.timestamp) {
    return {
      hasConflict: true,
      type: getConflictType(localOp, remoteOp),
      winner: remoteOp,
      loser: localOp,
      resolution: 'remote_wins'
    };
  }
  // ... handle other cases
}
```

### 2. Optimistic Updates with Rollback

**File:** `src/hooks/useOptimisticUpdates.ts`

```typescript
interface PendingOperation {
  id: string;
  operation: Operation;
  timestamp: number;
  timeout: NodeJS.Timeout;
}

function useOptimisticUpdates() {
  const [pending, setPending] = useState<PendingOperation[]>([]);
  
  const applyOptimistic = (operation: Operation) => {
    // Apply to local state immediately
    applyToCanvas(operation);
    
    // Track as pending
    const pendingOp = {
      id: generateId(),
      operation,
      timestamp: Date.now(),
      timeout: setTimeout(() => rollback(operation), 5000) // Rollback if no confirm
    };
    setPending(prev => [...prev, pendingOp]);
  };
  
  const confirmOptimistic = (operationId: string) => {
    // Server confirmed, remove from pending
    setPending(prev => {
      const op = prev.find(p => p.id === operationId);
      if (op) clearTimeout(op.timeout);
      return prev.filter(p => p.id !== operationId);
    });
  };
  
  const rollbackOptimistic = (operation: Operation) => {
    // Server rejected or timeout, revert
    revertCanvasOperation(operation);
    showConflictToast("Your change was overwritten");
  };
  
  return { applyOptimistic, confirmOptimistic, rollbackOptimistic };
}
```

### 3. Visual Conflict Indicators

**File:** `src/components/Canvas/ConflictIndicator.tsx`

```typescript
interface ConflictIndicatorProps {
  shapeId: string;
  conflictType: ConflictType;
  overwrittenBy: string;
  duration?: number;
}

function ConflictIndicator({ shapeId, conflictType, overwrittenBy, duration = 2000 }: ConflictIndicatorProps) {
  const [visible, setVisible] = useState(true);
  
  useEffect(() => {
    const timer = setTimeout(() => setVisible(false), duration);
    return () => clearTimeout(timer);
  }, []);
  
  if (!visible) return null;
  
  return (
    <div className="absolute animate-flash-red">
      {/* Red flash outline on shape */}
      <div className="border-4 border-red-500 rounded-lg animate-pulse" />
      
      {/* Toast notification */}
      <Toast type="warning">
        Your change was overwritten by {overwrittenBy}
      </Toast>
    </div>
  );
}
```

---

## Implementation Tasks Breakdown

### Phase 1: Foundation (Tasks 13.5.1 - 13.5.3)
- Document strategy
- Build conflict detection utilities
- Enhance shape metadata (version, timestamp, sessionId)

**Estimated Time:** 2-3 hours

### Phase 2: Optimistic Updates (Task 13.5.4)
- Implement optimistic update hook
- Add pending operations queue
- Build rollback mechanism

**Estimated Time:** 3-4 hours

### Phase 3: Visual Feedback (Tasks 13.5.5 - 13.5.6)
- Create conflict indicator component
- Add toast notifications
- Implement conflict logging

**Estimated Time:** 2-3 hours

### Phase 4: Conflict Scenarios (Tasks 13.5.7 - 13.5.10)
- Handle simultaneous move
- Handle rapid edit storm
- Handle delete vs edit
- Handle create collision

**Estimated Time:** 4-5 hours

### Phase 5: UI & Polish (Tasks 13.5.11 - 13.5.12)
- Conflict resolution panel
- Rate limiting
- Performance optimization

**Estimated Time:** 2-3 hours

### Phase 6: Testing (Task 13.5.13)
- Integration tests for all scenarios
- Manual testing with 2-3 concurrent users
- Performance testing (10+ edits/sec)

**Estimated Time:** 3-4 hours

**Total Estimated Time:** 16-22 hours

---

## Testing Strategy

### Automated Tests

```typescript
// tests/integration/conflict-resolution.test.ts

describe('Conflict Resolution', () => {
  it('handles simultaneous move', async () => {
    // Setup two users
    const userA = createTestUser('A');
    const userB = createTestUser('B');
    
    // Both select same shape
    const shape = createShape({ x: 100, y: 100 });
    
    // User A drags to (200, 100)
    await userA.dragShape(shape.id, { x: 200, y: 100 });
    
    // User B drags to (100, 200) - 20ms later
    await delay(20);
    await userB.dragShape(shape.id, { x: 100, y: 200 });
    
    // Wait for sync
    await waitForSync();
    
    // Both users should see (100, 200) - last write wins
    expect(userA.getShape(shape.id).x).toBe(100);
    expect(userA.getShape(shape.id).y).toBe(200);
    expect(userB.getShape(shape.id).x).toBe(100);
    expect(userB.getShape(shape.id).y).toBe(200);
    
    // User A should see conflict indicator
    expect(userA.hasConflictIndicator(shape.id)).toBe(true);
  });
  
  // ... more tests for each scenario
});
```

### Manual Testing Checklist

- [ ] Open 2 browser windows side by side
- [ ] Log in as different users in each
- [ ] Test Scenario 1: Simultaneous Move
  - [ ] Both users drag same shape at once
  - [ ] Last edit wins (check timestamps)
  - [ ] Loser sees red flash + toast
  - [ ] No ghost shapes
- [ ] Test Scenario 2: Rapid Edit Storm
  - [ ] User A resizes shape
  - [ ] User B changes color (immediately after)
  - [ ] User C moves shape (immediately after)
  - [ ] All properties resolve correctly
  - [ ] No corruption
- [ ] Test Scenario 3: Delete vs Edit
  - [ ] User A deletes shape
  - [ ] User B is mid-drag
  - [ ] Shape stays deleted
  - [ ] User B sees toast explaining deletion
- [ ] Test Scenario 4: Create Collision
  - [ ] Both users create shapes at same spot
  - [ ] Both shapes exist (no merge)
  - [ ] Different IDs confirmed

---

## Performance Considerations

### Rate Limiting Strategy

**Problem:** Rapid edits (10+ per second) can exhaust Firestore quotas.

**Solution:**
```typescript
// src/utils/rateLimiter.ts

const RATE_LIMIT = 10; // Max 10 updates/second per shape
const WINDOW = 1000; // 1 second window

function rateLimitUpdate(shapeId: string, operation: Operation) {
  const now = Date.now();
  const key = `shape:${shapeId}`;
  
  // Get update count in current window
  const updates = getUpdateCount(key, now - WINDOW, now);
  
  if (updates >= RATE_LIMIT) {
    // Queue for later (debounce)
    queueUpdate(shapeId, operation);
    return false;
  }
  
  // Allow update
  recordUpdate(key, now);
  return true;
}
```

### Optimistic Update Performance

- **Target:** < 50ms perceived latency for all edits
- **Technique:** Apply to local state immediately, sync to Firestore async
- **Tradeoff:** May need to rollback if conflict detected

### Memory Management

- **Pending Operations Queue:** Max 50 operations per user
- **Conflict Logs:** Max 100 entries (FIFO, dev mode only)
- **Cleanup:** Remove confirmed operations after 5 seconds

---

## Edge Cases & Solutions

### Edge Case 1: Network Partition
**Scenario:** User loses connection mid-edit  
**Solution:** Queue updates locally, sync on reconnect, show offline indicator

### Edge Case 2: Clock Skew
**Scenario:** User's device clock is wrong  
**Solution:** Use Firestore server timestamps (not client time)

### Edge Case 3: Concurrent Deletes
**Scenario:** Two users delete same shape at once  
**Solution:** First delete wins, second is no-op (shape already gone)

### Edge Case 4: Undo After Conflict
**Scenario:** User undoes, but shape was changed by others  
**Solution:** Undo uses snapshot, may conflict again, show warning

---

## Documentation

### User-Facing Docs

**File:** `docs/CONFLICT_RESOLUTION.md`

```markdown
# Conflict Resolution in CollabCanvas

## How It Works

When multiple users edit the same object simultaneously, CollabCanvas uses a "Last-Write-Wins" strategy:
- The most recent edit (based on server timestamp) wins
- Earlier edits are overwritten
- Users see a notification when their edit is overwritten

## Visual Feedback

- **Red Flash:** Your shape flashes red when overwritten
- **Toast Notification:** "Your change was overwritten by [User Name]"
- **Duration:** Indicators disappear after 2 seconds

## Common Scenarios

### Simultaneous Move
If you and another user drag the same shape at the same time, the last user to release their mouse wins.

### Rapid Edits
Multiple quick edits (resize, color, move) are resolved independently per property.

### Delete vs Edit
If someone deletes a shape you're editing, the delete wins. You'll see a notification.
```

---

## Rubric Alignment

This PR directly addresses rubric requirements:

**Section 1: Collaborative Infrastructure**
- âœ… "Two users edit same object simultaneously â†’ both see consistent final state"
- âœ… "Documented strategy (last-write-wins, CRDT, OT, etc.)"
- âœ… "No 'ghost' objects or duplicates"
- âœ… "Rapid edits (10+ changes/sec) don't corrupt state"
- âœ… "Clear visual feedback on who last edited"

**Success Criteria:**
- All 4 testing scenarios pass
- Conflict indicators work reliably
- No data corruption under load
- Performance targets met (< 50ms detection, < 100ms feedback)

---

## Future Enhancements (Out of Scope)

These are NOT included in PR #13.5 but could be future work:

1. **Operational Transform (OT):** More sophisticated conflict resolution
2. **CRDT (Conflict-free Replicated Data Types):** True merging instead of LWW
3. **Undo/Redo Across Users:** Cross-user operation history
4. **Conflict Resolution History:** Review past conflicts
5. **Custom Conflict Policies:** User chooses "always keep mine" etc.

---

**Status:** Ready for implementation ðŸš€

