# PR #13.5 - Conflict Resolution Quick Reference

**Status:** ðŸ“‹ Ready for Implementation  
**Priority:** High  
**Estimated Time:** 16-22 hours  
**Complexity:** Medium-High

---

## What This PR Does

Implements robust conflict resolution when multiple users edit the same shape simultaneously:

1. **Detects conflicts** explicitly (not just implicit Firestore behavior)
2. **Shows visual feedback** (red flash + toast) when your edit is overwritten
3. **Resolves using Last-Write-Wins** (most recent server timestamp wins)
4. **Handles edge cases** (delete vs edit, rapid storms, etc.)
5. **Prevents data corruption** with rate limiting and validation

---

## Key Components

### 1. Conflict Detection (`src/utils/conflictDetection.ts`)
```typescript
detectConflict(localOp, remoteOp) â†’ ConflictResult
getConflictType(op1, op2) â†’ ConflictType
shouldResolveConflict(localTs, remoteTs) â†’ boolean
```

### 2. Optimistic Updates (`src/hooks/useOptimisticUpdates.ts`)
```typescript
applyOptimistic(operation) â†’ void  // Apply instantly
confirmOptimistic(id) â†’ void       // Server confirmed
rollbackOptimistic(operation) â†’ void // Server rejected
```

### 3. Visual Feedback (`src/components/Canvas/ConflictIndicator.tsx`)
```typescript
<ConflictIndicator 
  shapeId="shape-123"
  conflictType="simultaneous_move"
  overwrittenBy="User B"
  duration={2000}
/>
```

### 4. Rate Limiter (`src/utils/rateLimiter.ts`)
```typescript
rateLimitUpdate(shapeId, operation) â†’ boolean
// Max 10 updates/second per shape
```

---

## Implementation Order

### âœ… Phase 1: Foundation (3 hours)
1. Create `docs/CONFLICT_RESOLUTION.md` (strategy doc)
2. Build `src/utils/conflictDetection.ts` (detection logic)
3. Update Shape interface (add version, timestamp, sessionId)

### âœ… Phase 2: Optimistic Updates (4 hours)
4. Create `src/hooks/useOptimisticUpdates.ts`
5. Implement pending queue + rollback

### âœ… Phase 3: Visual Feedback (3 hours)
6. Create `src/components/Canvas/ConflictIndicator.tsx`
7. Add toast notifications
8. Implement `src/utils/conflictLogger.ts`

### âœ… Phase 4: Scenarios (5 hours)
9. Handle simultaneous move
10. Handle rapid edit storm
11. Handle delete vs edit
12. Handle create collision

### âœ… Phase 5: Polish (3 hours)
13. Create conflict resolution panel UI
14. Add rate limiting
15. Performance optimization

### âœ… Phase 6: Testing (4 hours)
16. Write integration tests
17. Manual testing with 2-3 users
18. Performance testing (10+ edits/sec)

---

## Testing Quick Checklist

### Manual Test (2 browsers)

**Scenario 1: Simultaneous Move (2 min)**
- [ ] Both users drag same shape
- [ ] Last user wins
- [ ] First user sees red flash + toast
- [ ] No ghost shapes

**Scenario 2: Rapid Edit Storm (2 min)**
- [ ] User A resizes
- [ ] User B colors (immediately)
- [ ] User C moves (immediately)
- [ ] All converge to correct state
- [ ] No corruption

**Scenario 3: Delete vs Edit (2 min)**
- [ ] User B drags shape
- [ ] User A deletes (mid-drag)
- [ ] Shape deleted
- [ ] User B sees toast
- [ ] No ghost shape

**Scenario 4: Create Collision (1 min)**
- [ ] Both create at same spot
- [ ] Both shapes exist
- [ ] Different IDs

**Total Manual Test Time:** ~7 minutes

---

## Success Criteria

âœ… **Functional Requirements:**
- [ ] Conflict detection works for all 4 scenarios
- [ ] Visual feedback (flash + toast) appears within 100ms
- [ ] LWW resolution documented and implemented
- [ ] No ghost objects or duplicates
- [ ] Rapid edits (10/sec) handled without corruption

âœ… **Performance Requirements:**
- [ ] Conflict detection: < 50ms
- [ ] Visual feedback: < 100ms
- [ ] Optimistic update: instant (< 16ms)
- [ ] Rollback: < 100ms
- [ ] Rate limit: 10 updates/sec enforced

âœ… **Testing Requirements:**
- [ ] 4 integration tests pass
- [ ] Manual tests pass
- [ ] Performance tests pass
- [ ] No console errors during conflicts

---

## Code Snippets

### Add to Shape Interface
```typescript
export interface Shape {
  // ... existing fields
  version: number;
  lastModifiedTimestamp: number;
  editSessionId?: string;
}
```

### Update Shape Example
```typescript
await updateShape(id, {
  x: 100,
  y: 200,
  version: shape.version + 1,
  lastModifiedTimestamp: serverTimestamp(),
  lastModifiedBy: currentUser.uid,
  editSessionId: currentSessionId
});
```

### Detect Conflict Example
```typescript
const conflict = detectConflict(
  { timestamp: 1000, type: 'move', shapeId: 'abc' },
  { timestamp: 1020, type: 'move', shapeId: 'abc' }
);

if (conflict.hasConflict) {
  showConflictIndicator(conflict.loser.userId, conflict.winner.userId);
}
```

---

## Files to Create

1. `docs/CONFLICT_RESOLUTION.md` - Strategy documentation
2. `src/utils/conflictDetection.ts` - Conflict detection logic
3. `src/hooks/useOptimisticUpdates.ts` - Optimistic updates
4. `src/components/Canvas/ConflictIndicator.tsx` - Visual feedback
5. `src/utils/conflictLogger.ts` - Logging system
6. `src/components/UI/ConflictResolutionPanel.tsx` - Optional UI
7. `src/utils/rateLimiter.ts` - Rate limiting
8. `tests/integration/conflict-resolution.test.ts` - Tests

## Files to Update

1. `src/contexts/CanvasContext.tsx` - Add version/timestamp tracking
2. `src/services/canvas.ts` - Use serverTimestamp()
3. `src/components/Canvas/Canvas.tsx` - Integrate conflict indicators

---

## Common Issues & Solutions

### Issue: Optimistic update feels delayed
**Solution:** Apply to local state synchronously, don't wait for Firestore

### Issue: Conflict indicators too aggressive
**Solution:** Add 100ms debounce, only show if conflict persists

### Issue: Rate limiting too strict
**Solution:** Increase to 15-20 updates/sec, add burst allowance

### Issue: Timestamp skew on client
**Solution:** Always use Firestore serverTimestamp(), never client Date.now()

---

## Performance Tips

1. **Debounce drag updates:** 100ms instead of every mousemove
2. **Batch Firestore writes:** Use writeBatch() for multiple shapes
3. **Memoize conflict detection:** Cache results for 100ms
4. **Lazy load indicators:** Don't render until conflict happens
5. **Cleanup old logs:** Keep only last 100 conflict events

---

## Rubric Impact

This PR is **critical for rubric Section 1** (Collaborative Infrastructure):

âœ… "Two users edit same object simultaneously â†’ both see consistent final state"  
âœ… "Documented strategy (last-write-wins, CRDT, OT, etc.)"  
âœ… "No 'ghost' objects or duplicates"  
âœ… "Rapid edits (10+ changes/sec) don't corrupt state"  
âœ… "Clear visual feedback on who last edited"

**Expected Score Impact:** Moves from "Basic sync" to "Production-grade conflict resolution"

---

## Next Steps After This PR

1. **PR #14:** Alignment Tools (can build on conflict-free foundation)
2. **PR #22:** Performance Optimization (conflict detection is already optimized)
3. **PR #23:** Persistence Hardening (add conflict replay on reconnect)

---

**Ready to implement!** ðŸš€

See `PR13.5_CONFLICT_RESOLUTION_SPEC.md` for full technical details.

